# -*- coding: utf-8 -*-
"""GA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k9rW7AE0Ss-hUUlBRCoqA17C15UYwKDN

The idea is that I can load in the dinnerly dataset and then use this as the dataset to choose from for the GA.  We have 56 meals to choose from and we plan on picking 6 each week.  That give 56C6 which is 32,468,436 different combinations!  This is why I'm using a GA because this is a bit intractable to brute force if we increased to say selecting for one of the weeks 7 meals instead of 6.  That then is 231,917,400 possible combinations.

The goal is to minimize the grocery bill needed to purchase the required ingredients.  The thing is that some of the meals may have the same ingredient such as ground beef.  However, each meal only uses so much ground beef.  So the idea is to for each ingredient to sum up the quantity used accross all the meals for the individual and then use that to calculate how many units need to be purchased of that ingrediant and multiply that by the unit price.  Then sum that up for all the ingrediants.  That then is the fitness of the individual 

Individual

What is an individual?  An individual is a set of 6 (k) meals.  This is a set because we want unique meals.  We want 6 because we plan on having pizza once a week.  An individual is represented as a set of the keys into the table with the ingredients for that meal.

Cross-Over



Mutation


Fitness
"""


import pandas as pd


ingredients_sheet = sheet.worksheet("ingredients")
rows = ingredients_sheet.get_all_values()
ingredient_df = pd.DataFrame.from_records(rows[1:], columns=rows[0])

import random
import numpy as np
import math
from deap import algorithms, base, creator, tools
from datetime import datetime


def fillSetInd(container, func, n):
    a = set()
    while True:
        a.add(func())
        if len(a) == n:
            break
    return container(a)


def getCost(individual, meal_df):

    shoppingList = {
        "ingredient": [],
        "quantity to purchase": [],
        "quantity sold in": [],
        "unit price (at kroger)": [],
        "total cost (at kroger)": [],
        "meals used in": [],
    }
    cost = 0.0
    items = {}
    ingredients = {}
    price = {}
    type_counts = {}
    meals_used_in = {}

    for meal_id in individual:
        meal_type = meal_df.iloc[meal_id]["type"]
        type_counts[meal_type] = type_counts.get(meal_type, 0.0) + 1
        for i, row in ingredient_df[
            ingredient_df["meal"] == meal_df.iloc[meal_id]["recipe name"]
        ].iterrows():
            items[row["ingredient"]] = items.get(row["ingredient"], 0.0) + float(
                row["quantity in recipe"]
            )

            if row["ingredient"] in meals_used_in:
                meals_used_in[row["ingredient"]].append(row["meal"])
            else:
                meals_used_in[row["ingredient"]] = []
                meals_used_in[row["ingredient"]].append(row["meal"])

            ingredients[row["ingredient"]] = float(row["quantity sold"])
            price[row["ingredient"]] = float(row["price (at kroger)"])

    for k, v in items.items():
        # k is ingredient name and v is total quantity used in the recipes

        shoppingList["ingredient"].append(k)
        quantity_to_purchase = math.ceil(v / ingredients[k])
        shoppingList["quantity to purchase"].append(quantity_to_purchase)
        shoppingList["quantity sold in"].append(ingredients[k])
        shoppingList["unit price (at kroger)"].append(price[k])
        shoppingList["total cost (at kroger)"].append(quantity_to_purchase * price[k])
        shoppingList["meals used in"].append(str(set(meals_used_in[k])))

        cost += quantity_to_purchase * price[k]

    return cost, shoppingList


def evalKnapsack(individual, meal_df=None):
    cost = 0.0
    items = {}
    ingredients = {}
    price = {}
    type_counts = {}

    for meal_id in individual:
        try:
            meal_type = meal_df.iloc[meal_id]["type"]
        except:
            print(individual)

        type_counts[meal_type] = type_counts.get(meal_type, 0.0) + 1
        for i, row in ingredient_df[
            ingredient_df["meal"] == meal_df.iloc[meal_id]["recipe name"]
        ].iterrows():
            items[row["ingredient"]] = items.get(row["ingredient"], 0.0) + float(
                row["quantity in recipe"]
            )
            ingredients[row["ingredient"]] = float(row["quantity sold"])
            price[row["ingredient"]] = float(row["price (at kroger)"])

    for k, v in items.items():
        cost += math.ceil(v / ingredients[k]) * price[k]

    cost = cost / 80.0 + max(type_counts.values())  # max of the meal types
    # can then also take into account things like not wanting to have
    # all of the same meat, and also could subtract ingredients that we already
    # have from the previous week(s) from the cost and somehow take note of that
    # that may need to improve the representation of the individual...

    return (cost,)


def cxSet(ind1, ind2):
    """Apply a crossover operation on input sets. The children are made by randomly
    selecting 3 meals from one individual and unioning that with the other individual
    then selecting 7 meals randomly from that union to make the new individual.
    """

    indLen = len(ind1)
    half = int(indLen / 2)
    temp = set(
        random.sample(
            list(set(random.sample(list(ind1), k=half)) | set(ind2)), k=indLen
        )
    )
    temp2 = set(
        random.sample(
            list(set(random.sample(list(ind2), k=half)) | set(ind1)), k=indLen
        )
    )

    return creator.Individual(temp), creator.Individual(temp2)


def mutSet(individual, meal_df=None):
    """Mutation that randomly changes one of the meals"""
    tempInd = list(individual)

    while True:
        index = random.sample(range(len(tempInd)), 1)[0]
        newMeal = random.sample(range(len(meal_df)), 1)[0]
        tempInd[index] = newMeal
        if len(set(tempInd)) == len(individual):
            break

    return (creator.Individual(set(tempInd)),)


def optimizeMeals(numMeals=6, meal_df=None):

    IND_INIT_SIZE = numMeals

    NBR_MEALS = len(meal_df)

    print(NBR_MEALS)

    creator.create("Fitness", base.Fitness, weights=(-1.0,))
    creator.create("Individual", set, fitness=creator.Fitness)

    toolbox = base.Toolbox()
    toolbox.register("attr_item", random.randrange, NBR_MEALS)
    toolbox.register(
        "individual", fillSetInd, creator.Individual, toolbox.attr_item, IND_INIT_SIZE
    )
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)

    toolbox.register("evaluate", evalKnapsack, meal_df=meal_df)
    toolbox.register("mate", cxSet)
    toolbox.register("mutate", mutSet, meal_df=meal_df)
    toolbox.register("select", tools.selTournament, tournsize=3)

    NGEN = 10
    MU = 50
    LAMBDA = 100
    CXPB = 0.7
    MUTPB = 0.2

    pop = toolbox.population(n=MU)
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean, axis=0)
    stats.register("std", np.std, axis=0)
    stats.register("min", np.min, axis=0)
    stats.register("max", np.max, axis=0)
    algorithms.eaSimple(
        pop,
        toolbox,
        cxpb=0.5,
        mutpb=0.2,
        ngen=NGEN,
        stats=stats,
        halloffame=hof,
        verbose=True,
    )
    # algorithms.eaMuPlusLambda(pop, toolbox, MU, LAMBDA, CXPB, MUTPB, NGEN, stats,
    #                           halloffame=hof)

    return pop, stats, hof


def main():

    meals_sheet = sheet.worksheet("meals")
    meal_rows = meals_sheet.get_all_values()
    meal_df = pd.DataFrame.from_records(meal_rows[1:], columns=meal_rows[0])
    print(len(meal_df))
    numWeeks = 4
    # https://docs.gspread.org/en/latest/user-guide.html#selecting-a-worksheet
    sh = gc.create(f"Meal Plan")

    for i in range(numWeeks):

        shopping_sh = sh.add_worksheet(
            title=f"shopping list {i}", rows="500", cols="20"
        )
        meal_list_sh = sh.add_worksheet(title=f"meal list {i}", rows="500", cols="20")

        meal_list = {"meal": [], "cost": []}

        numMeals = 6
        pop, stats, hof = optimizeMeals(numMeals, meal_df)

        b = [i for i in hof.items]

        cost, shoppingList = getCost(b[0], meal_df)
        print(f"week {i} cost = {cost}")
        for k in b[0]:
            print(meal_df.iloc[k]["recipe name"])
            meal_list["meal"].append(meal_df.iloc[k]["recipe name"])
            meal_list["cost"].append(cost / numMeals)

        meal_list["meal"].append("total")
        meal_list["cost"].append(cost)

        shoppingListDF = pd.DataFrame(shoppingList)
        shopping_sh.update(
            [shoppingListDF.columns.values.tolist()] + shoppingListDF.values.tolist()
        )

        meal_listDF = pd.DataFrame(meal_list)
        meal_list_sh.update(
            [meal_listDF.columns.values.tolist()] + meal_listDF.values.tolist()
        )

        # drop the hall of fame meals so don't get same meals
        #
        drop_ind = list(b[0])
        meal_df = meal_df.drop(drop_ind).reset_index(drop=True)
        print(len(meal_df))


main()
